// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License"). You may
// not use this file except in compliance with the License. A copy of the
// License is located at
//
//     http://aws.amazon.com/apache2.0/
//
// or in the "license" file accompanying this file. This file is distributed
// on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
// express or implied. See the License for the specific language governing
// permissions and limitations under the License.

// Code generated by ack-generate. DO NOT EDIT.

package target_group

import (
	"context"
	"time"

	svcapitypes "github.com/aws-controllers-k8s/elbv2-controller/apis/v1alpha1"
	ackcompare "github.com/aws-controllers-k8s/runtime/pkg/compare"
	ackrtlog "github.com/aws-controllers-k8s/runtime/pkg/runtime/log"
	"github.com/aws/aws-sdk-go-v2/aws"
	svcsdk "github.com/aws/aws-sdk-go-v2/service/elasticloadbalancingv2"
	svcsdktypes "github.com/aws/aws-sdk-go-v2/service/elasticloadbalancingv2/types"

	"github.com/aws-controllers-k8s/elbv2-controller/pkg/resource/tags"
)

var (
	RequeueAfterUpdateDuration = 5 * time.Second
)

func customCompare(
	delta *ackcompare.Delta,
	a *resource,
	b *resource,
) {
	compareTargetDescription(delta, a, b)
}

func compareTargetDescription(
	delta *ackcompare.Delta,
	desired *resource,
	latest *resource,
) {
	if len(desired.ko.Spec.Targets) != len(latest.ko.Spec.Targets) {
		delta.Add("Spec.Targets", desired.ko.Spec.Targets, latest.ko.Spec.Targets)
	} else if len(desired.ko.Spec.Targets) > 0 {
		added, removed := getTargetsDifference(latest.ko.Spec.Targets, desired.ko.Spec.Targets)

		if len(added) > 0 || len(removed) > 0 {
			delta.Add("Spec.Targets", added, removed)
		}
		return

	}
}

func areDifferentTarget(latest, desired *svcapitypes.TargetDescription) bool {
	if (latest == nil && desired != nil) || (latest != nil && desired == nil) {
		return true
	}

	if latest.Port != nil && desired.Port == nil {
		desired.Port = latest.Port
	}
	if latest.AvailabilityZone != nil && desired.AvailabilityZone == nil {
		desired.AvailabilityZone = latest.AvailabilityZone
	}
	if (latest.ID == nil && desired.ID != nil) || (latest.ID != nil && desired.ID == nil) ||
		(latest.ID != nil && desired.ID != nil && *latest.ID != *desired.ID) ||
		(latest.Port == nil && desired.Port != nil) || (latest.Port != nil && desired.Port != nil && *latest.Port != *desired.Port) ||
		(latest.AvailabilityZone == nil && desired.AvailabilityZone != nil) ||
		(latest.AvailabilityZone != nil && desired.AvailabilityZone != nil && *latest.AvailabilityZone != *desired.AvailabilityZone) {
		return true
	}

	return false
}

func getTargetsDifference(
	latest []*svcapitypes.TargetDescription,
	desired []*svcapitypes.TargetDescription,
) (added []*svcapitypes.TargetDescription, removed []*svcapitypes.TargetDescription) {

	toAdd := make([]*svcapitypes.TargetDescription, 0, min(len(latest), len(desired)))
	toDelete := make([]*svcapitypes.TargetDescription, 0, min(len(latest), len(desired)))

	am := make(map[string]*svcapitypes.TargetDescription)

	for _, v := range latest {
		am[*v.ID] = v
	}

	for _, v := range desired {
		if t, ok := am[*v.ID]; !ok || areDifferentTarget(t, v) {
			toAdd = append(toAdd, v)
		}
	}

	bm := make(map[string]*svcapitypes.TargetDescription)
	for _, v := range desired {
		bm[*v.ID] = v
	}

	for _, v := range latest {
		if _, ok := bm[*v.ID]; !ok {
			toDelete = append(toDelete, v)
		}
	}

	return toAdd, toDelete
}

func (rm *resourceManager) registerTargets(
	ctx context.Context,
	arn string,
	targets []*svcapitypes.TargetDescription,
) (err error) {

	rlog := ackrtlog.FromContext(ctx)
	exit := rlog.Trace("rm.registerTargets")
	defer func() { exit(err) }()

	input := &svcsdk.RegisterTargetsInput{
		TargetGroupArn: &arn,
		Targets:        apifyTargetDescription(targets),
	}
	_, err = rm.sdkapi.RegisterTargets(ctx, input)
	rm.metrics.RecordAPICall("UPDATE", "RegisterTargets", err)
	if err != nil {
		return err
	}

	return nil
}

func (rm *resourceManager) deregisterTargets(
	ctx context.Context,
	arn string,
	targets []*svcapitypes.TargetDescription,
) (err error) {
	if len(targets) == 0 {
		return nil
	}

	rlog := ackrtlog.FromContext(ctx)
	exit := rlog.Trace("rm.deregisterTargets")
	defer func() { exit(err) }()

	input := &svcsdk.DeregisterTargetsInput{
		TargetGroupArn: &arn,
		Targets:        apifyTargetDescription(targets),
	}
	_, err = rm.sdkapi.DeregisterTargets(ctx, input)
	rm.metrics.RecordAPICall("UPDATE", "DeregisterTargets", err)
	if err != nil {
		return err
	}

	return nil
}

func (rm *resourceManager) describeTargets(
	ctx context.Context,
	res *resource,
) (err error) {
	rlog := ackrtlog.FromContext(ctx)
	exit := rlog.Trace("rm.describeTargets")
	defer func() { exit(err) }()

	input := &svcsdk.DescribeTargetHealthInput{
		TargetGroupArn: (*string)(res.ko.Status.ACKResourceMetadata.ARN),
	}
	resp, err := rm.sdkapi.DescribeTargetHealth(ctx, input)
	rm.metrics.RecordAPICall("READ_MANY", "DescribeTargetHealth", err)
	if err != nil {
		return err
	}

	targetHealthPtrs := make([]*svcsdktypes.TargetHealthDescription, len(resp.TargetHealthDescriptions))
	for i := range resp.TargetHealthDescriptions {
		targetHealthPtrs[i] = &resp.TargetHealthDescriptions[i]
	}
	res.ko.Spec.Targets = extractTargetDescription(targetHealthPtrs)
	return nil
}

func apifyTargetDescription(target []*svcapitypes.TargetDescription) []svcsdktypes.TargetDescription {
	convertedTarget := make([]svcsdktypes.TargetDescription, len(target))
	for i, t := range target {
		td := svcsdktypes.TargetDescription{
			Id:               t.ID,
			AvailabilityZone: t.AvailabilityZone,
		}
		if t.Port != nil {
			td.Port = aws.Int32(int32(*t.Port))
		}
		convertedTarget[i] = td
	}
	return convertedTarget
}

func extractTargetDescription(targetHealth []*svcsdktypes.TargetHealthDescription) []*svcapitypes.TargetDescription {
	convertedTarget := make([]*svcapitypes.TargetDescription, 0, len(targetHealth))
	for _, t := range targetHealth {
		if t.Target == nil {
			continue
		}
		td := &svcapitypes.TargetDescription{
			ID:               t.Target.Id,
			AvailabilityZone: t.Target.AvailabilityZone,
		}
		if t.Target.Port != nil {
			td.Port = aws.Int64(int64(*t.Target.Port))
		}
		convertedTarget = append(convertedTarget, td)
	}
	return convertedTarget
}

func (rm *resourceManager) getTags(
	ctx context.Context,
	resourceARN  string,
) ([]*svcapitypes.Tag, error) {
	return tags.GetResourceTags(ctx, rm.sdkapi, rm.metrics, resourceARN )
}

func (rm *resourceManager) updateTags(
	ctx context.Context,
	desired *resource,
	latest *resource,
) (err error) {
	rlog := ackrtlog.FromContext(ctx)
	exit := rlog.Trace("rm.describeTargets")
	defer func() { exit(err) }()
	return tags.SyncRecourseTags(ctx, rm.sdkapi, rm.metrics, string(*desired.ko.Status.ACKResourceMetadata.ARN), desired.ko.Spec.Tags, latest.ko.Spec.Tags)
}